package main //обьяснение кода начинается с входной точки. т.е func main

import (
	"fmt" //прошу заметить пакетов импорта всего ничего
	"os"
	"strconv"
)

func romToara(a string) int { //тут мы создаем функцию принимающую в себя строку и возвращающая int

	rml := map[string]int{ //обьявляем карту с нашими числами которые входят в диапазон входных чисел
		"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5,
		"VI": 6, "VII": 7, "VIII": 8, "IX": 9, "X": 10,
	}
	for k, v := range rml { //запускаем цикл в котором проверяем наличие ключа
		if a == k {
			return v //если нашелся , возвращаем значение ключа
		}
	}
	panic("неизвестное число") //если нет, Сорян чо! дальше в блок обработки оператора эт вниз этажей на 40

}
func intToRom(n int) string { //эта функция обратной конвертации. принимает число возвращает строку
	rml := []struct { //создаем структуру для расчета суммы ведь сумма будет в диапазоне от 1 до 100
		val int // тут мы создаем наши поля шаблоны
		rom string
	}{
		{100, "C"}, {90, "XC"}, {50, "L"}, {40, "XL"},
		{10, "X"}, {9, "IX"}, {5, "V"}, {4, "IV"}, {1, "I"}, //это наши шаблоны
	}
	result := ""            //создаем переменную котрая ждет пополнения строкой
	for _, v := range rml { // обьявляем цикл который пробегается по нашей структуре.
		for n >= v.val { //если цифра больше или равно ключу. это указанно так для того что бы он искал сначала максимальное число
			result += v.rom //прибавляем к результату значение ключа
			n -= v.val      //отнимаем одно число т.к его уже преобразовали
		}
	}
	return result //возвращаем результат
}
func main() { //старт
	var a, b string                                  //обьявляем переменные с типом строка это будут числа
	var s string                                     //эта переменная будет оператором
	var err = ""                                     //отлавливаем ошибку пустого ввода
	fmt.Println("Введите математическое выражение:") //предлагаем ввести операцию
	fmt.Fscanln(os.Stdin, &a, &s, &b, &err)          //сканируем переменные и ошибку
	if err != "" {                                   //если пусто выводим сообщение о пустом вводе
		panic("Ошибка пустой ввод")

	}
	if _, err := strconv.Atoi(a); err == nil { //тут блок проверки являются ли a и b арабскими числами
		if _, err := strconv.Atoi(b); err != nil { //заодно проверяем что у нас оба числа либо строка либо число.
			panic("строка b отличается от a")
		}
	} else {
		if _, err := strconv.Atoi(b); err == nil {
			panic("строка а отличается от б")
		}
	}
	var count int = 0 //тут мы обьявляем счетчик костыль:D который будет считать загонялась ли наша переменная в функцию или нет
	numA, _ := strconv.Atoi(a)
	if numA == 0 {
		numA = romToara(a) //если a не получилось конвертировать в число то загоняем ее в функцию
		count++            //фиксируем что была попытка конвертировать через функцию
	}
	numB, _ := strconv.Atoi(b) //здесь тоже самое
	if numB == 0 {
		numB = romToara(b)
		count++
	}

	if numA < 1 || numA > 10 { //проверяем на вход в диапазон входных чисел
		panic("число a не входит  в диапазон 1-10")
	}

	if numB < 1 || numB > 10 {
		panic("число б не входит в диапазон 1-10")
	}
	var result int //создаем переменную для приема результата дальше идем в блок функции конвертации romToara (этажей на 40 выше)
	switch s {     // тут мы используем конструкцию Switch и думаю тут очевидно все и понятно
	case "+": //так же хочу отметить что можно реализовать это и через отдельные функции. но так меньше читаемость кода
		result = numA + numB //дальше ниже
	case "-":
		result = numA - numB
	case "*":
		result = numA * numB
	case "/":
		result = numA / numB
	default:
		panic("неизвестный оператор")

	}
	if count == 2 { //теперь если наш костыль счетчик указал нам что числа были преобразованы через функцию
		fmt.Println(intToRom(result)) // мы загоняем в функцию обратной конвертации эт выше этажей на 30
	} else {
		fmt.Println(result) //а вот если костыль молчит значит над просто вывести результат
	} //ну тут в приницпе конец.

}
